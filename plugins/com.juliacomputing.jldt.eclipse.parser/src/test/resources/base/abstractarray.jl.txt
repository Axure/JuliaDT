(unit (statement (typeDeclaration typealias AbstractVector (typeParameters { (typeParameter (exp T)) }) (exp (typeExpression AbstractArray { (exp (exp T) , (exp 1)) })))) (statement (typeDeclaration typealias AbstractMatrix (typeParameters { (typeParameter (exp T)) }) (exp (typeExpression AbstractArray { (exp (exp T) , (exp 2)) })))) (statement (typeDeclaration typealias AbstractVecOrMat (typeParameters { (typeParameter (exp T)) }) (exp (typeExpression Union { (typeExpression AbstractVector { (exp T) }) , (typeExpression AbstractMatrix { (exp T) }) })))) (statement (typeDeclaration typealias RangeIndex (exp (typeExpression Union { (typeExpression Int) , (typeExpression Range { (exp Int) }) , (typeExpression UnitRange { (exp Int) }) , (typeExpression Colon) })))) (statement (functionDeclaration (name vect) (parameters ( )) = (exp (name Array) ( (exp Any) , (exp 0) )))) (statement (functionDeclaration (name vect) (typeParameters { (typeParameter (exp T)) }) (parameters ( (parameter (parameter X :: (typeExpression T)) ...) )) = (exp T))) (statement (exp [ (exp (exp X) [ (exp i) ]) for i = (exp 1) : (exp (name length) ( (exp X) )) ])) (statement (exp const _oldstyle_array_vcat_ = (exp true))) (statement (exp if (exp _oldstyle_array_vcat_) (statement (functionDeclaration function (name oldstyle_vcat_warning) (parameters ( (parameter n :: (typeExpression Int)) )) (statement (exp if (exp (exp (exp n) == (exp 1 before)) = (exp "[a]")) (statement (exp (exp after) = (exp "collect(a)"))) elseif (exp (exp (exp n) == (exp 2 before)) = (exp "[a,b]")) (statement (exp (exp after) = (exp "[a;b]"))) else (statement (exp (exp before) = (exp "[a,b,...]"))) (statement (exp (exp after) = (exp "[a;b;...]"))) end)) (statement (exp (name depwarn) ( (exp "$before concatenation is deprecated; use $after instead") , (exp : (exp vect)) ))) end)) (statement (functionDeclaration function (name vect) (parameters ( (parameter (parameter A :: (typeExpression AbstractArray)) ...) )) (statement (exp (name oldstyle_vcat_warning) ( (exp (name length) ( (exp A) )) ))) (statement (exp (name vcat) ( (exp (exp A) ...) ))) end)) (statement (functionDeclaration function (name vect) (parameters ( (parameter (parameter X) ...) )) (statement (forStatement for (exp a) in (exp X) (statement (exp if (exp (exp (name typeof) ( (exp a) )) <: (exp AbstractArray)) (statement (exp (name oldstyle_vcat_warning) ( (exp (name length) ( (exp X) )) ))) (statement (exp break)) end)) end)) (statement (exp (name vcat) ( (exp (exp X) ...) ))) end)) else (statement (functionDeclaration function (name vect) (parameters ( (parameter (parameter X) ...) )) (statement (exp (exp T) = (exp (name promote_typeof) ( (exp (exp X) ...) )))) (statement (exp (name copy!) ( (exp (name Array) ( (exp T) , (exp (name length) ( (exp X) )) )) , (exp X) ))) end)) end)) (statement (functionDeclaration (name size) (typeParameters { (typeParameter (exp (exp T) , (exp n))) }) (parameters ( (parameter t :: (typeExpression AbstractArray { (exp (exp T) , (exp n)) })) , (parameter d) )) = (exp (exp d) <= (exp (exp n) ? (exp (exp (name size) ( (exp t) )) [ (exp d) ]) : (exp 1 size))))) (statement (exp (exp ( (exp (exp (exp (exp x) , (exp (exp d1) :: (typeExpression Integer))) , (exp (exp d2) :: (typeExpression Integer))) , (exp (exp (exp dx) :: (typeExpression Integer)) ...)) )) = (exp (name tuple) ( (exp (name size) ( (exp x) , (exp d1) )) , (exp (exp (name size) ( (exp (exp x) , (exp d2)) , (exp (exp dx) ...) )) ...) )))) (statement (functionDeclaration (name eltype) (typeParameters { (typeParameter (exp T)) }) (parameters ( (parameter :: (typeExpression Type { (exp (typeExpression AbstractArray { (exp T) })) })) )) = (exp T))) (statement (functionDeclaration (name eltype) (typeParameters { (typeParameter (exp (exp T) , (exp n))) }) (parameters ( (parameter :: (typeExpression Type { (exp (typeExpression AbstractArray { (exp (exp T) , (exp n)) })) })) )) = (exp T))) (statement (functionDeclaration (name elsize) (typeParameters { (typeParameter (exp T)) }) (parameters ( (parameter :: (typeExpression AbstractArray { (exp T) })) )) = (exp (name sizeof) ( (exp T) )))) (statement (functionDeclaration (name ndims) (typeParameters { (typeParameter (exp (exp T) , (exp n))) }) (parameters ( (parameter :: (typeExpression AbstractArray { (exp (exp T) , (exp n)) })) )) = (exp n))) (statement (functionDeclaration (name ndims) (typeParameters { (typeParameter (exp (exp T) , (exp n))) }) (parameters ( (parameter :: (typeExpression Type { (exp (typeExpression AbstractArray { (exp (exp T) , (exp n)) })) })) )) = (exp n))) (statement (functionDeclaration (name ndims) (typeParameters { (typeParameter T <: (typeExpression AbstractArray)) }) (parameters ( (parameter :: (typeExpression Type { (exp T) })) )) = (exp (name ndims) ( (exp (name super) ( (exp T) )) )))) (statement (functionDeclaration (name length) (parameters ( (parameter t :: (typeExpression AbstractArray)) )) = (exp (exp (name prod) ( (exp (name size) ( (exp t) )) )) :: (typeExpression Int)))) (statement (functionDeclaration (name endof) (parameters ( (parameter a :: (typeExpression AbstractArray)) )) = (exp (name length) ( (exp a) )))) (statement (functionDeclaration (name first) (parameters ( (parameter a :: (typeExpression AbstractArray)) )) = (exp (exp a) [ (exp (name first) ( (exp (name eachindex) ( (exp a) )) )) ]))) (statement (functionDeclaration function (name first) (parameters ( (parameter itr) )) (statement (exp (exp state) = (exp (name start) ( (exp itr) )))) (statement (exp (exp (name done) ( (exp itr) , (exp state) )) && (exp (name throw) ( (exp (name ArgumentError) ( (exp "collection must be non-empty") )) )))) (statement (exp (exp (name next) ( (exp itr) , (exp state) )) [ (exp 1) ])) end)) (statement (functionDeclaration (name last) (parameters ( (parameter a) )) = (exp (exp a) [ (exp end) ]))) (statement (functionDeclaration function (name stride) (parameters ( (parameter a :: (typeExpression AbstractArray)) , (parameter i :: (typeExpression Integer)) )) (statement (exp if (exp (exp i) > (exp (name ndims) ( (exp a) ))) (statement (exp return (exp (name length) ( (exp a) )))) end)) (statement (exp (exp s) = (exp 1))) (statement (forStatement for (exp n) = (exp 1) : (exp ( (exp (exp i) - (exp 1)) )) (statement (exp (exp s) *= (exp (name size) ( (exp a) , (exp n) )))) end)) (statement (exp return (exp s))) end)) (statement (functionDeclaration (name strides) (parameters ( (parameter a :: (typeExpression AbstractArray)) )) = (exp (exp (name ntuple) ( (exp (exp i) -> (exp (name stride) ( (exp a) , (exp i) ))) , (exp (name ndims) ( (exp a) )) )) :: (typeExpression Dims)))) (statement (functionDeclaration function (name isassigned) (parameters ( (parameter a :: (typeExpression AbstractArray)) , (parameter (parameter i :: (typeExpression Int)) ...) )) (statement (exp try)) (statement (exp (exp a) [ (exp (exp i) ...) ])) (statement (exp true)) (statement (exp catch)) (statement (exp false)) end)))